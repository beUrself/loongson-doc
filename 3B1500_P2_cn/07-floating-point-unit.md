浮点协处理器
============

本章描述了龙芯 3B 处理器浮点协处理器（Floting Point Unit，简称 FPU）的特性， 包
括编程模型、指令集和指令格式、指令流水线以及异常。龙芯 3B 浮点协处理器及其相关
的系统软件完全符合 ANSI/IEEE 754－1985 二进制浮点运算标准。另外，龙芯 3B 浮点协
处 理器能够处理自定义的 64 位 SIMD 多媒体定点指令集。

概述
----

FPU 作为 CPU 的协处理器，被称为 CP1（Coprocessor 1），通过扩展 CPU 的指令集来 完
成浮点算术运算功能。 FPU 由以下两个功能单元组成：

* FALU1 单元
* FALU2 单元

FALU1 模块可以执行除浮点访存以及浮点和定点数据传送之外的所有浮点操作, 包括 浮点
加（减）法、浮点乘法、浮点乘加（减），浮点除法，浮点开平方根，浮点求倒，浮点 开
根后求倒，浮点与定点转换,浮点精度转换, 浮点比较, 转移判断和其它简单逻辑等。此 外
，FALU1 模块通过指令编码中 FMT 域的扩展与复用来执行 SIMD 媒体操作。

FALU2 执行浮点乘加运算部件（可计算浮点乘、加和浮点乘加指令），浮点与定点转换, 浮
点精度转换, 浮点比较，和其它简单逻辑等以及媒体 SIMD 指令操作。同时，龙芯 3B 的
FPU 支持执行 MIPS64 指令集中的并行单精度（Paired-Single，简称 PS）浮点指令。图\
\ref{fig:function-units} 对龙芯 3B 体系结构中功能单元的组织构成进行了图解说明。

![龙芯 3B 功能单元的组织构成 \label{fig:function-units}](../images/functional-units.pdf)

浮点队列每个时钟周期可以分别发射 1 条指令到 FALU1 单元、1 条指令到 FALU2 单元。
浮点寄存器文件为 FALU1 单元与 FALU2 单元各提供三个专用的读端口和一个专用的写端
口。

FPU 寄存器
----------

这部分描述 FPU 寄存器组和它们的数据组织结构。龙芯 3B 的 FPU 寄存器与 MIPS64 的
FPU 寄存器兼容。MIPS64 的 FPU 寄存器包括浮点寄存器和浮点控制寄存器。其中浮点控制
寄 存器包括 FIR（1 号） 、FCSR（31 号）、FCCR（25 号） 、FEXR（26 号）、FENR（28
号）等。

### 浮点寄存器

龙芯 3B 的浮点寄存器沿袭 R10000 用法，与 MIPS64 略有不同。在 Status 控制寄存器的
FR 位为 1 时，均有 32 个 64 位的浮点寄存器，如下图所示；在 Status 控制寄存器的
FR 位 为 0 时，R10000 只有 16 个 32 位或 64 位的浮点寄存器，而 MIPS64 表示有 32
个 32 位的浮 点寄存器或 16 个 64 位的浮点寄存器。


图 7-2 浮点寄存器格式
f1                            f0
f3                            f2
f5                            f4
f7                            f6
f9                            f8
f11                           f10
f13                           f12
f15                           f14
f17                           f16
f19                           f18
f21                           f20
f23                           f22
f25                           f24
f27                           f26
f29                           f28
f31                           f30

### FIR 寄存器（CP1，0）

FIR 是 32 位只读寄存器，它包含了浮点单元实现的功能，如处理器 ID，修订版本号等 信
息。龙芯 3B 里 FIR 的初始值为 0x00770501。图 7-3 显示了 FIR 寄存器的格式，表 7-1
描述了该寄存器的域。

图 7-3 FIR 寄存器

表 7-1 FIR 寄存器域
              域                                                 描 述
 0                         保留。必须按 0 写入，读时返回 0。
 Impl                      实现相关
                           浮点数据通路是否为 64 位
 F64                       0－32 位
                           1－64 位
                           长字（64 位）定点数据类型是否实现
 L                         0－未实现
                           1－已实现
                           字（32 位）定点数据类型是否实现
 W                         0－未实现
                           1－已实现
                           MIPS-3D ASE 是否实现
 3D                        0－未实现
                           1－已实现
                           浮点对数据类型是否实现
 PS
                           0－未实现
                           1－已实现
                             双精度浮点数据类型是否实现
 D                           0－未实现
                             1－已实现
                             单精度浮点数据类型是否实现
 S                           0－未实现
                             1－已实现
 ProcessorID                 浮点处理器标识
 Revision                    浮点单元的修订版本号


### FCSR 寄存器（CP1，31）

FCSR 寄存器用于控制浮点单元的操作和表示一些状态。GS464V 中 FCSR 的初始值为
0x00000F80。如图 7-4 所示是 FCSR 寄存器的格式，表 7-2 描述了 FCSR 寄存器的域。其
中 E、 V、Z、O、U、I 分别表示未实现操作、无效操作、除零、上溢、下溢、不精确。

图 7-4 FCSR 寄存器

表 7-2 FCSR 寄存器域
      域                  描 述
      0                  保留。必须按 0 写入，读时返回 0。
      FCC                浮点条件码。记录浮点比较结果，用于条件跳转或转移。
      FS                 冲刷到 0。这位设置时，非正常运算的结果将被设为 0，而不是产生一个例外
      Impl               实现相关，GS464V 使用 FSCR[21]作为 top_mode，该位用于在译码时指示要不要
               使用 X86 的 TOP 寄存器对浮点寄存器号进行重命名。
     Cause       当产生浮点运算的例外时，相应位被设置。
     Enables     是否允许相应的条件产生例外。
     Flags       是否有 IEEE 的浮点例外产生。
                                 （比如 Enables 里未打开相应位可查看本字段）
                 双精度浮点数据类型是否实现
     RM          0－未实现
                 1－已实现

控制/状态寄存器条件（CC0）位

当一个浮点比较操作发生时，结果被保存在 CC0 位，即条件位。如果比较结果为真，则
CC0 位被置 1；反之则置 0。CC0 位仅能被浮点比较指令和 CTC1 指令所修改。
控制/状态寄存器导致(Causes)域

控制/状态寄存器的位 17：12 为导致（Causes）域，如表 7-3 所示，这些位反映了最近
执行指令的结果。Causes 域是协处理器 0 的 Cause 寄存器的一个逻辑扩充，这些位指示了
由上次浮点操作所引起的例外，并且如果相应的使能位（Enable）被设置的话则产生一个中
断或者例外。如果一条指令中产生不只一个例外，每一个相应的例外导致位都要被设置。

Causes 域能被每条浮点操作指令所重写（不包括 Load、Store、Move 操作）。其中如果
需要软件仿真来完成的则把该操作的未实现操作位（E）置 1，否则保持为 0。其它位则依照
IEEE754 标准看是否相应的例外产生而分别置 1 或者置 0。

当一个浮点例外发生，没有结果将被存储，状态唯一受影响的就是 Causes 域。

表 7-3 Cause 寄存器域
                         域       描 述
                         17      E（未实现指令）
                         16      V（非法指令）。
                         15      Z（除零）。
                         14      O（上溢）。
                         13      U（下溢）。
                         12      I（结果不精确）。

控制/状态寄存器使能(Enables)域

任何时候当 Cause 位和相应的使能位（Enable）同时为 1 时，会产生一个浮点例外。如
  果浮点操作设置了一个被允许激活（相应使能位为 1）的 Cause 位，则处理器会立即产生一
  个例外，这和用 CTC1 指令同时设置 Cause 位和 Enable 位为 1 的效果一样。
          对于未实现操作(E)来说没有相应的使能位，如果设置了未实现操作，它总是会产生一
  个浮点例外。
          在从一个浮点例外返回之前，软件首先必须用一个 CTC1 指令来清除被激活了的 Cause
  位以防止中断的重复执行。因此，在用户态下的运行的程序永远不会观察到被使能的 Cause
  位的值为 1；如果用户态的处理程序需要获得该信息，则 Cause 位的内容必须被传递到其它
  地方而不是在状态寄存器中。
          如果浮点操作只设置未被使能（相应的使能位为 0）的 Cause 位，则没有例外发生，同
  时 IEEE754 标准定义的默认结果被写回。在这种情况下，前一条浮点指令所引起的例外能够
  通过读 Causes 域的值来确定。
  控制/状态寄存器标志(Flags)域
          标志位是累积的，它指示自从上次被明确重置后发生了例外。如果一个 IEEE754 例外被
  产生，那么相应的 Flag 位被置 1，否则保持不变，因此对于浮点运算来说这些位永不会被
  清除。但是可以通过 CTC1 控制指令写一个新值到状态寄存器中来实现对 Flag 位的设置或清
  除。
          当一个浮点例外发生时，Flag 位并不由硬件来设置；浮点例外的处理软件有责任在调
  用用户程序之前设置这些位。
  控制/状态寄存器的舍入模式(RM)域
          控制/状态寄存器中第 0 位和第 1 位组成了舍入模式（RM）域。如表 7-4 中所示，FPU
  根据这些位所指定的舍入方式来对所有的浮点运算进行相应的舍入处理。

表 7-4 舍入模式位解码

舍入模式 助记符 描述
RM(1:0)
0          RN   把结果向最接近可表示数的方向舍入，当两个最接近可表示数离结果一样接近时，
                则向最低位为 0 的那个最接近数方向舍入。
1          RZ   向 0 方向舍入：把结果向与之最接近并且在绝对值上不大于它的那个数舍入。
2          RP   向正无穷大方向舍入:把结果向与之最接近并且不小于它的那个数舍入
3          RM   向负无穷大方向舍入：把结果向与之最接近并且不大于它的那个数舍入

### FCCR 寄存器（CP1，25）

FCCR 寄存器是访问 FCC 字段的另一种方式，其内容与 FCSR 里的 FCC 位完全相同，不同
的是在本寄存器中的 FCC 位是连续的。图 7-5 是 FCCR 寄存器的格式。

图 7-5 FCCR 寄存器

### FEXR 寄存器（CP1，26）

FEXR 寄存器是访问 Cause 和 Flags 字段的另一种方式，其内容与 FCSR 里的相应字段完
全相同。图 7-6 显示了 FEXR 寄存器的格式。

图 7-6 FEXR 寄存器


### FENR 寄存器（CP1，28）

FENR 寄存器是访问 Enable, FS 和 RM 字段的另一种方式，其内容与 FCSR 里的相应字段
完全相同。图 7-7 显示了 FENR 寄存器的格式。

图 7-7 FENR 寄存器

指令集概述
----------

GS464V 实现了 MIPS64 中 FPU 部分的所有数据类型，包括 S，D，W，L，和可选的 PS。

表 7-5 列出了 GS464V 中 MIPS64 部分的 FPU 指令。

表 7-5 MIPS64 的 FPU 指令集

OpCode    Description                            MIPS ISA
算术指令 
ABS.fmt            绝对值                                            MIPS32
ADD.fmt            加法                                             MIPS32
DIV.fmt            除法                                             MIPS32
MADD.fmt           乘加                                             MIPS64
MSUB.fmt           乘减                                             MIPS64
MUL.fmt            乘法                                             MIPS32
NEG.fmt            求反                                             MIPS32
NMADD.fmt          乘加后求反                                          MIPS64
NMSUB.fmt          乘减后求反                                          MIPS64
RECIP.fmt          求倒数                                            MIPS64
RSQRT.fmt          平方根后求倒数                                        MIPS64
SQRT.fmt           平方根                                            MIPS32
SUB.fmt       减法                      MIPS32
分支跳转指令
BC1F          浮点假时跳转                  MIPS32
BC1FL         浮点假时 Likely 跳转          MIPS32
BC1T          浮点真时跳转                  MIPS32
BC1TL         浮点真时 Likely 跳转          MIPS32
比较指令
C.cond.fmt    比较浮点值并置标志位              MIPS32
转换指令
ALNV.PS        可变浮点对齐                  MIPS64
CEIL.L.fmt     浮点转换到 64 位定点，向上取整       MIPS64
CEIL.W.fmt     浮点转换到 32 位定点，向上取整       MIPS64
CVT.D.fmt      浮点或定点转换到双精度浮点           MIPS32
CVT.L.fmt      转换浮点值到 64 位定点           MIPS64
CVT.PS.S       转换两个浮点值到浮点对             MIPS64
CVT.S.PL       转换浮点对的低位到单精度浮点          MIPS64
CVT.S.PL       转换浮点对的高位到单精度浮点          MIPS64
CVT.S.fmt      浮点或定点转换到单精度浮点           MIPS32
CVT.W.fmt      转换浮点值到 32 位定点           MIPS32
FLOOR.L.fmt    浮点转换到 64 位定点，向下取整       MIPS64
FLOOR.W.fmt    浮点转换到 32 位定点，向下取整       MIPS64
PLL.PS         合并两个浮点对的低位为新的浮点对        MIPS64
PLU.PS         合并两个浮点对的低位和高位为新的浮点对     MIPS64
PUL.PS         合并两个浮点对的高位和低位为新的浮点对     MIPS64
PUU.PS         合并两个浮点对的高位为新的浮点对        MIPS64
ROUND.L.fmt    把浮点数四舍五入到 64 位定点        MIPS64
ROUND.W.fmt   把浮点数四舍五入到 32 位定点           MIPS32
TRUNC.L.fmt   把浮点数向绝对值小的方向舍入到 64 位定点     MIPS64
TRUNC.W.fmt   把浮点数向绝对值小的方向舍入到 32 位定点     MIPS32
访存指令
LDC1          从内存取双字                     MIPS32
LDXC1         按索引从内存取双字                  MIPS64
LUXC1         按非对齐索引从内存取双字               MIPS64
LWC1          从内存取字                      MIPS32
LWXC1         按索引从内存取字                   MIPS64
SDC1          存双字到内存                     MIPS32
SDXC1         按索引存双字到内存                  MIPS64
SUXC1         按非对齐索引存双字到内存               MIPS64
SWC1          存字到内存                      MIPS32
SWXC1         按索引存字到内存                   MIPS64
MOVE 指令
CFC1          读浮点控制寄存器到 GPR              MIPS32
CTC1          写浮点控制寄存器到 GPR              MIPS32
DMFC1         从 FPR 复制双字到 GPR            MIPS64
DMTC1         从 GPR 复制双字到 FPR            MIPS64
MFC1          从 FPR 复制低字到 GPR            MIPS32
MFHC1         从 FPR 复制高字到 GPR            MIPS32 R2
MOV.fmt       复制 FPR                     MIPS32
MOVF.fmt      浮点假时复制 FPR                 MIPS32
MOVN.fmt      GPR 不为 0 时复制 FPR           MIPS32
MOVT.fmt      浮点真时复制 FPR                 MIPS32
MOVZ.fmt      GPR 为 0 时复制 FPR            MIPS32
MTC1                       从 GPR 复制低字到 FPR                                   MIPS32
MTHC1                      从 GPR 复制高字到 FPR                                   MIPS32 R2

GS464V 与 MIPS64 Release 2 版本兼容，从功能上实现了 MIPS64 体系结构规定的所有
FPU 指令，但是有些指令在实现上有细微的并不影响兼容性但是比较重要的差别，以下两
点值得编程人员注意。

（1）乘加、乘减指令。在执行 MADD.fmt，MSUB.fmt，NMADD.fmt，NMSUB.fmt 这
四组指令时，GS464V 的运算结果与 MIPS64 处理器略有不同，这是因为 GS464V 在做乘加
运算时只在最后结果处做精度舍入，而 MIPS64 处理器在进行乘运算后就进行了一次舍入，
加运算后又做了一次舍入，导致了最终结果最低位相差 1。

（2）单精度运算指令。

在 Status 控制寄存器的 FR 位为 0 时，abs.s, add.s, ceil.w.d, ceil.w.s, div.s,
floor.w.d, floor.w.s, mul.s, neg.s, round.w.d, round.w.s, sqrt.s, sub.s,
trunc.w.d, trunc.w.s, mov.s, cvt.d.s, cvt.d.w, cvt.s.d, cvt.s.w, cvt.w.d,
cvt.w.s, movf.s, movn.s, movt.s, movz.s 等 26 条指令不能使用奇数号寄存器，而
MIPS64 体系结构的处理器就可以，在这点上龙芯沿用了 MIPS R4000 与 MIPSR10000 的做
法，与 MIPS64 的规定略有不同。（早期的 MIPS 处理器中 FR 位表示浮点寄存器是 16 个
还是 32 个，MIPS64 中 FR 位表示浮点寄存器是 32 位还是 64 位）。

浮点部件格式
------------

### 浮点格式

FPU 既可以对 32 位（单精度）也可以对 64 位（双精度）符合 IEEE 标准的浮点数进行操
作。32 位的单精度格式包括一个 24 比特的以符号－幅度表示的小数域（F＋S）和一个 8
比特的指数域（E）；64 位的双精度格式包括一个 53 比特的符号－幅度表示的小数域（F
＋S）和一个 11 比特的指数域（E）；64 位双精度（PS）格式包含两个单精度浮点格式。
分别如图 7-8 所示。

单精度格式                                       双精度格式
                                    PS格式（双单精度）
                                        双单精度格式
                                      图 7-8 浮点格式

正如图 7-8 所示，浮点数的格式由以下三个域组成：
      符号域，S
      带偏移的指数域，E = E0 + Bias，E0 是不带偏移的指数
      小数域，F= .b1 b2....bp–1
      指数 E0 的范围是包括 Emin 和 Emax 在内的所有二者之间的整数，另外再加上以下两个保留
值：
      Emin - 1 （用来编码 0 和非规格化数）
      Emax +1 （用来编码∞和 NaN[Not a Number]）
      对于单精度或者双精度格式来说，每一个可表示的非 0 数都有唯一一种编码与之对应。
其编码所对应的数值 V 由表 7-6 中的等式所决定。

表 7-6 计算单精度和双精度格式的浮点数的值的公式
                  NO.                             公式
                  (1)     if E0 = Emax+1 and F≠0, then V = NaN, regardless of s
                  (2)           if E0 = Emax+1 and F = 0, then V= (–1)S∞
                  (3)            if Emin≤E0≤Emax, then V = (–1)S2 E0 (1.F)
                  (4)       if E0 = Emin–1 and F≠0, then V= (–1)S2Emin(0.F)
                (5)           if E0 = Emin–1 and F = 0, then V = (–1)S0

对于所有的浮点格式，如果 V 是一个 NaN，那么 F 的最高位决定了这个数是 Signaling
NaN 还是 Quiet NaN：如果 F 的最高位被设置，那么 V 是 Signaling NaN，否则 V 是
Quiet NaN。

表 7-7 定义了一些浮点格式的相关参数的值；浮点的最大值和最小值在表 7-8 中给出。

表 7-7 浮点格式参数值
                 参数                                        格式
                                            单精度                           双精度
                  Emax                        +127                        +1203
                  Emin                        -126                        -1022
               指数偏移量                          +127                        +1023
               指数位宽度                            8                          11
                整数位                     隐藏（Hidden）                隐藏（Hidden）
              F (小数位宽度)                        24                          53
               格式总宽度                           32                          64

表 7-8 最大数和最小数的浮点值
                         类型                                值
                      单精度浮点最小数                       1.40129846e–45
                  单精度浮点最小正规数                         1.17549435e–38
                      单精度浮点最大数                       3.40282347e+38
                      双精度浮点最小数                4.9406564584124654e–324
                  双精度浮点最小正规数                  2.2250738585072014e–308
                  双精度浮点最大数                    1.7976931348623157e+308

### 多媒体指令格式

多媒体指令为每 64 位数据引入了新的包裹(Packed)数据类型，数据元素可以有如下几类：

*  8 个包裹，每个包裹是一个连续的 8 位字节
*  4 个包裹，每个包裹是一个连续的 16 位半字
*  2 个包裹，每个包裹是一个连续的 32 位字
*  1 个 64 位双字

这 64 位被编号为 0－63。位 0 是最低位(LSB)，位 63 是最高位(MSB)。较低位相应存放
数据低位，较高位存放数据高位。例如，一个半字包含位 0 到位 15 一共 16 位，如果在
一个半字中的一个字节包含位 0 到位 7，那么它在这个半字中称为低字节，如果是包含位
8 到位 15，那么叫做高字节。

包裹的整形数据以两种格式保存，无符号和符号。例如，图 7-9 说明了包裹的无符号半字
格式，图 7-10 说明了包裹的有符号半字格式。

图 7-9 包裹的无符号半字格式

图 7-10 包裹的有符号半字格式

指令流水线概述
--------------

FPU 提供一个和 CPU 指令流水线并行的指令流水线。它和 CPU 共享基本的 9 级流水线体
系结构，但根据浮点操作的不同，执行流水级又细分为 2~6 个流水级。每个 FPU 指令被两个
浮点功能单元中的一个执行：FALU1 或者 FALU2。FALU1 可以执行所有的浮点运算操作及媒
体操作。FALU2 执行除浮点除法/求倒数，开方/开方倒数以外的全部浮运算操作以及媒体操
作。

每个 FALU 单元每个周期能够分别接收 1 条指令，并能向浮点寄存器文件分别送出一个
结果。在每个 FALU 单元中，浮点加减运算需要 5 个执行周期,浮点乘法、浮点乘加运算需
要 6 个执行周期；定点与浮点间的格式转换运算需要 4 个执行周期；浮点除法根据操作数的
不同需要 4~16 个执行周期；浮点开平方根根据操作数的不同需要 4~31 个执行周期，其它
浮点运算需要 2 个执行周期。在每个 FALU 单元中，如果两条有着不同执行周期的指令在同
一拍输出结果，在这种情况下，执行周期较短的指令优先向总线输出结果。其中除浮点除法
和浮点开根之外的浮点操作和所有媒体操作都是全流水的。如果同时有两个浮点除法指令或
者两个浮点开平方根指令在 FALU1 中，那么 FALU1 单元将向前一流水级发出一个停顿信
号，并且 FALU1 单元在除法或开平方根指令写回前不能接收新的指令。

浮点例外处理
------------

该节描述了浮点计算的例外。浮点例外发生在当 FPU 不能以常规的方式处理操作数或者
浮点计算的结果时，FPU 产生相应的例外来启动相应的软件陷阱或者是设置状态标志位。

FPU 的控制和状态寄存器对于每一种例外都包含一个使能位，使能位决定一个例外是否
能够导致 FPU 启动一个例外陷阱或者设置一个状态标志。

如果一个陷阱启动，FPU 保持操作开始的状态，启动软件例外处理路径；如果没有陷阱
启动，一个适当的值写到 FPU 目标寄存器中，计算继续进行。

FPU 支持五个 IEEE754 例外：

不精确 Inexact (I)
      下溢 Underflow (U)
      上溢 Overflow (O)
      除零 Division by Zero (Z)
      非法操作 Invalid Operation (V)
      以及第六个例外：
      未实现操作 Unimplemented Operation（E）

未实现操作例外用在当 FPU 不能执行标准的 MIPS 浮点结构，包括 FPU 不能决定正确的
例外行为的情况。这个例外指示了软件例外处理的执行。未实现操作例外没有使能信号和标
志位，当这个例外发生时，一个相应的未实现例外陷阱发生。

IEEE754 的 5 个例外（V，Z，O，U，I）都对应着一个由用户控制的例外陷阱，当 5 个
使能位的某一位被设置时，相应的例外陷阱被允许发生。当例外发生时，相应的导致（Cause）
位被设置，如果相应的使能（Enable）位没有设置，例外标志（Flag）位被设置。如果使能
位被设置，那么标志位不被设置，同时 FPU 产生一个例外给 CPU。随后的例外处理允许该例
外陷阱发生。

当没有例外陷阱信号时，浮点处理器采取缺省方式进行处理，提供一个浮点计算例外结
果的替代值。不同的例外类型决定了不同的缺省值。表 7-9 列出了 FPU 对于每个 IEEE 例外
的默认处理。

表 7-9 例外的默认处理

域       描述       舍入模式                         默认操作
I     非精确例外      Any     提供舍入后的结果
                   RN      根据中间结果的符号把结果置 0
 U      下溢例外       RZ      根据中间结果的符号把结果置 0
                   RP      把正下溢修正为最小正数，把负下溢修正为-0
                   RM      把负下溢修正为最小负数,把正下溢修正为+0
                   RN      根据中间结果的符号把结果置为无穷大
 O      上溢例外       RZ      根据中间结果的符号把结果置为最大数
                   RP      把负下溢修正为最大负数,把正下溢修正为+∞
                   RM      把正下溢修正为最大整数,把负下溢修正为-∞
 Z       被0除       Any     提供一个相应的带符号的无穷大数
 V      非法操作       Any     提供一个 Quiet Not a Number(QNaN)

下面对导致 FPU 产生每种例外的条件进行了描述，并且详细说明了 FPU 对每个例外导致
条件的反应。

不精确例外 (I)

FPU 在发生如下的情况时产生不精确例外：
      舍入结果非精确
      舍入结果上溢
      舍入结果下溢，并且下溢和不精确的使能位都没有被设置，而且 FS 位被设置。
      陷阱被使能的结果：如果一个非精确例外陷阱被使能，结果寄存器不被修改，并且源
寄存器被保留。因为这种执行模式会影响性能，所以不精确例外陷阱只有在必要的时候才被
使能。

陷阱不被使能的结果：如果没有其他软件陷阱发生，舍入或者上溢结果被发送到目标
寄存器。

非法操作例外 (V)

当一个可执行的操作的两个操作数或其中的一个操作数是非法时，非法操作例外发出信号通
知。如果例外没有陷入，MIPS 定义这个结果是一个 Quiet Not a Number（QNaN）。非法操
作包括：

加法或者减法：无穷相减。例如：(+∞)+(- ∞)或者(-∞)-(- ∞)
      乘法：0×∞，对于所有的正数和负数
      除法：0/0，∞/∞，对于所有的正数和负数
      当不处理 Unordered 的比较操作的操作数是 Unordered
      对一个指示信号 NaN 进行浮点比较或者转换
      任何对 SNaN（Signaling NaN）的数学操作。当其中一个操作数为 SNaN 或者两个
都为 SNaN 时会导致这个例外（MOV 操作不被认为是数学操作，但 ABS 和 NEG 被认为是
数学操作）

开方： X ，当 X 小于 0 时
      软件可以模拟其他给定源操作数的非法操作的例外。例如在 IEEE754 中利用软件来实现
的特定函数：X REM Y，这里当 Y 是 0 或者 X 是无穷的时候；或者当浮点数转化为十进制时
发生上溢，是无穷或者是 NaN；或者先验函数例如：ln(5)或者 cos (3)。

陷阱被使能的结果：源操作数的值不被发送。
陷阱不使能的结果：如果没有其他例外发生，QNaN被发送到目标寄存器中。

除零例外 (Z)
      除法运算中当除数是 0 被除数是一个有限的非零的数据时，除零例外发出信号通知。利
用软件可以对其他操作产生有符号的无穷值时模拟除零例外，如：ln(0)，sin(π/2)，cos(0)，
      -1
或者 0 。

陷阱被使能的情况：结果寄存器不被修改，源寄存器保留。

陷阱不使能的情况：如果没有陷阱发生，结果是有符号的无穷值。

上溢例外 (O)

当舍入后的浮点结果的幅度用没有界限的指数来表示时，大于最大的目标模式所表示有
限数据，上溢例外发出通知信号。（这个例外同时设置不精确例外和标志位）

陷阱被使能的情况：结果寄存器不被修改，源寄存器保留。
陷阱不使能的情况：如果没有陷阱发生，最后的结果由舍入模式和中间结果的符号来
决定。

下溢例外 (U)

两个相关的事件导致了下溢例外：
一个很小的在±2Emin 之间的非零结果，由于该结果非常小，因此会导致其后发生下
溢例外。
      用非规格化数据（Denormalized Number）来近似表示这两个小数据所产生的严重
的数据失真。
      IEEE754 允许用多种不同的方法检测这些事件，但对于所有的操作要求用相同的方法来
检测。小数据可以用下面的方法的一种来检测：
      舍入后（如果一个非零的数据，在指数范围没有界限的情况下来计算，应该严格的
位于±2Emin 之间）
      舍入前（如果一个非零的数据，在指数和精度范围没有界限的情况下来计算，应该
严格的位于±2Emin 之间）
      MIPS 的结构要求微小数据在舍入后检测。精度失真可以用如下方法的一种来检测：
      非规格化数据的失真（当产生的结果与指数没有界限时计算的结果不同）
      非精确数据（当产生的结果与指数和精度范围没有界限的情况下计算的结果不同）
      MIPS 结构要求精度失真被检测为产生非精确结果。
      陷阱被使能的情况：如果下溢或者不精确例外被使能，或者FS位没有设置，产生未实
现操作例外，结果寄存器不被修改。
      陷阱不使能的情况：如果下溢或者不精确例外不被使能，而且FS位被设置，最后的结
果由舍入模式和立即结果的符号位来决定。
未实现操作例外 (E)
      当执行任何一条为以后定义所保留的操作码或者操作格式指令时，FPU 控制/状态寄存
器中的未实现操作导致位被设置并产生陷阱。源操作数和目的寄存器保持不变，同时指令在
软件中仿真。IEEE754 中的任何一个例外都能够从仿真操作中产生，这些例外反过来可以被
仿真。另外，当硬件不能正确执行一些罕见的操作或者结果条件时，也会产生未实现指令例
外。这些包括：
非规格化操作数（Denormalized Operand），比较指令除外
Quite Not a Number 操作数（QNaN），比较指令除外
非规格化数据或者下溢，而且当下溢或者不精确使能信号被设置同时 FS 位没有被
设置 注意: 非规格化和NaN操作只在转换或者计算指令中进入陷阱，在MOV指令中不进入
陷阱。

陷阱被使能的情况：原操作数据不被发送。
陷阱不使能的情况：这个陷阱不能被不使能。
