\chapter{性能优化}

本章提供了龙芯 GS464 体系结构中一些与软件性能优化相关的信息，包括指令延迟和
循环间隔、扩展指令、指令流和存储访问处理等，供编译器和其它软件开发者参
考。

\section{用户指令延迟和循环间隔}

\begin{table}[htbp]
  \centering
  \begin{tabular}{|l|c|c|c|} \hline
    操作 & 执行单元 & 延迟 & 循环间隔 \\ \hhline
    \multicolumn{4}{|l|}{整型操作} \\ \hline
    ADD/SUB/LOGICAL/SHIFT/LUI/CMP      & ALU1/2  & 2    & 1      \\ 
    TRAP/BRANCH                        & ALU1    & 2    & 1      \\ 
    MF/MT HI/LO                        & ALU1/2  & 2    & 1      \\ 
    (D)MULT(U)                         & ALU2    & 5    & 21     \\ 
    (D)MULT(U)G                        & ALU2    & 5    & 1      \\ 
    (D)DIV(U)                          & ALU2    & 5-38 & 10-763 \\ 
    (D)DIV(U)G                         & ALU2    & 5-38 & 4-37   \\ 
    (D)MOD(U)G                         & ALU2    & 5-38 & 4-37   \\ 
    取                                 & MEM     & 5    & 1      \\ 
    存                                 & MEM     & -    & 1      \\ \hhline
    \multicolumn{4}{|l|}{浮点操作} \\ \hline
    (D)MTC1/(D)MFC1                    & MEM     & 5    & 1      \\ 
    ABS/NEG/C.COND/BCLT/BC1F/MOVE/CVT* & FALU1   & 3    & 1      \\ 
    ROUND/TRUNC/CEIL/FLOOR/CVT*        & FALU1   & 5    & 1      \\ 
    ADD/SUB/MUL/MADD/MSUB/NMADD/NMSUB  & FALU1/2 & 7    & 1      \\ 
    DIV.S                              & FALU2   & 5-11 & 4-10   \\ 
    DIV.D                              & FALU2   & 5-18 & 4-17   \\ 
    SQRT.S                             & FALU2   & 5-17 & 4-16   \\ 
    SQRT.D                             & FALU2   & 5-32 & 4-31   \\ 
    LWC1/LDC1                          & MEM     & 5    & 1      \\ 
    SWC1/SDC1                          & MEM     & -    & 1      \\ \hline
  \end{tabular}
  \caption{}
  \label{tab:instr-delay}
\end{table}

表~\ref{tab:instr-delay} 给出了在 ALU1/2, MEM, FALU1/2 功能单元中执行的所有用户指令的延迟和
循环间隔（不包括内核指令和控制指令）。这里的指令延迟是指从该指令发射到其结果能
被下一条指令使用所需要的拍数（一个处理器周期为一拍）。例如，大部分的 ALU 指令
延迟为 2，这表示 ALU 指令的结果要隔一拍后才能被后续指令使用。因此，形如 $i = i + 1$
的相关循环（下一个循环依赖上一个循环的结果）不能每拍出一个结果。而一个指令的
循环间隔则是指功能部件接受这种指令的频度，1 表示每拍都能接受一个以上的同类指
令，$n$ 表示功能部件接受一个该指令后，需要等 $n-1$
拍后才能再接受同类指令。全流水功 能部件的指令循环间隔为 $1$。

\noindent 对于表~\ref{tab:instr-delay} 中的数据
\begin{itemize}
  \item 内存存取操作的循环间隔不包括 LL/SC 指令。这是因为 LL/SC
    是等待发射操作， 只有当它们位于 Reorder 队列队首，而且 CP0
    队列为空时，才可以被发射。
  \item 对于 HI/LO 寄存器，没有特别的使用限制： 它们可以当作通用寄存器一样被使用。
  \item 表中数据也不包含 CTC1/CFC1：它们和许多其它的控制指令一样被序列化。
  \item 表中数据也不包含多媒体指令。这是因为它们是通过扩展普通浮点指令的格式而完成
    的，它们的功能单元和延时与被扩展的指令相同。
\end{itemize}

\section{指令扩充}

龙芯 GS464 完成了以下几种指令扩充：
\begin{itemize}
  \item 只写一个结果到通用寄存器的定点乘除。包括 12 条指令：
    \begin{verbatim}
    (D)MULT.G,  (D)MOD.G,  (D)DIV.G,
    (D)MULTU.G, (D)MODU.G, (D)DIVU.G
    \end{verbatim}\vspace{-1.5em}
    在标准的 MIPS 指令集中，乘法和除法在一个操作中需要写两个特殊的结果寄存
    器(HI/LO)，它们在 RISC 流水线中很难实现。为了使用这些结果，将不得不使用额
    外的指令把它从 HI/LO 中取出送入通用寄存器中。更麻烦的是，由于流水线的问题，
    很多 MIPS 处理器对这些指令的使用还有些限制。这些新指令执行速度更快，同时
    也更容易使用。
 \item 多媒体指令的扩充。 它们是定点操作但使用浮点的数据通路。
   在执行定点程序的过程中，浮点数据通路常常处于空闲状态，这些指令使得我们
   有机会利用它们，进一步增加指令并行的程度。
\end{itemize}

\section{指令流}

龙芯 GS464 是一个多发射高度并行的处理器，对本质上是串行的指令流的处理可能会对
程序性能产生明显的影响，本节讨论关于指令对齐、转移指令、指令调度等问题。

\subsection{指令对齐}

在一个周期内，龙芯 GS464 可以从一个 Cache 行中取出四条指令，但这四条指令不能跨
越 Cache 行的边界。我们应该对那些经常性被执行的基本块进行合适的对齐，以避免跨
越 Cache 行的边界。此外，如果在一次所取的四条指令中存在转移指令，也会影响取指
的效率。如果第一条是转移分支指令，而且转移预测是成功，那么最后两条指令将被抛
弃。如果最后一条是转移指令，即使转移成功，处理器也不得不再取下一个 Cache 行以
得到它的延迟槽中的指令。龙芯 GS464 一个周期只能给一条转移指令译码，如果在一束指令
中存在两条转移指令的话，它将需要两个周期来完成译码，也就是说取指引擎将被阻塞
一个周期。

\subsection{转移指令的处理}

在龙芯 GS464 的处理器中，指令流地址的一个意想不到的变化会浪费大约 10 条指令的
时间。“意想不到” 可以是由转移成功的指令导致，也可能会由转移预测错误导致。对
于目前的龙芯 GS464 而言，即使是一个正确预测且预测转移成功的转移指令也比顺序代码
慢，它会浪费一个周期，因为对于普通条件转移指令，转移目标缓存器（BTB）不能给
出下一个正确的程序计数器 PC 值。

编译器可以通过以下的方法来减少转移指令引起的开销：
\begin{itemize}
  \item 龙芯 2 号的转移指令预测方法和其它的高性能处理器都不同，
    且不同的版本都有一些细微的差别。
    基于执行剖析（Profile)，编译器可以根据实际的转移频率对代码位置
    进行重新安排，从而得到较好的预测结果。
  \item 尽可能使基本块变大。 一种比较好的优化结果就是使得在两条转移成功的转移指
    令之间平均有 20 条指令。为了使它们之间至少含有 20 条指令，
    这就需要循环展开， 还要把不到 20 条指令的子程序直接内联展开。龙芯 GS464
    实现了条件性移动指令，它可以用 来减少分支指令数量。
    通过执行剖析来重新组织代码也有助于这个优化。
\end{itemize}

1.3 节给出了取指译码单元的一个概要描述。正如我们所见，不同的转移指令使用不
同的方式进行预测：
\begin{itemize}
  \item 静态预测。 针对 likely 类转移指令和直接跳转指令。
  \item G-Share 预测器。 一个 9 位的全局历史寄存器 GHR，  和一个有 2K
    项的模式历史表 PHT。用于条件 转移指令。
  \item BTB（转移目标缓存）。 有 16
    项的全相联的缓存。被用于预测寄存器跳转指令的目标地址。
  \item RAS（返回地址栈）。 4 项，被用于预测函数返回的目标地址。
\end{itemize}

以下有几点关于软件需要注意的地方：

在龙芯 GS464 处理器上需要特别小心地使用 Likely 类转移指令。尽管 Likely 类转移指
令也许对顺序标量处理器的简单的静态调度很有效，但是它对现代高性能处理器并不是
同样有效。因为现代高性能处理器的转移预测硬件是比较复杂，它们通常有 90\%以上的
正确预测率。（比如说，龙芯 GS464 能够正确预测 85\%-100\%，平均
95\%的条件转移的转移方向）在这种情况下，编译器不应该使用预测率不太高的 Likely
类转移指令。事实上， 我们发现带有 \verb+-mno-branch-likely+ 选项的 GCC（3.3
版）通常会工作得更好。

取指译码单元被划分成 3 个流水段，其中转移的目标地址在第三阶段被计算。转移
成功的转移指令将会导致有两个周期的停顿，也就是说，如果在周期 0 取出一条转移指
令，在周期 1 取出地址为 PC+16 的指令，      周期 2 取出地址为 PC+32 的指令，
在周期 3 时， 才会取到转移指令的目标地址。
所以减少转移成功的转移指令数将会比较有一些帮助。

龙芯 GS464 中的 BTB 仅被用于寄存器跳转指令(包括 JALR 及除 JR31 外的 JR 指令)。
通过一个 4 项的 RAS 来预测 JR31 指令的目标地址。函数返回的预测有效性取决于
那些使用 JR31 指令作为函数返回指令的软件。

\subsection{指令流密度的提高}

编译器应该尽量利用执行剖析，以确保调入指令 Cache 的那些字节均被执行。这就
要求跳转指令的目标地址需对齐，并且把那些很少被执行的代码移出 Cache 行。

\subsection{指令调度}

龙芯 GS464 内部有比较大的指令窗口会进行动态的指令调度，但是由于处理器内部各种
资源有限无法做到最优的调度，编译器可以在一定程度上协助处理器进行更好的调度。
现代的编译器（如 GCC）有指令调度的支持，把龙芯 GS464 内部的部件资源情况和指令的
延迟情况告诉编译器，它就能够进行较好的调度。

\subsection{存储器访问}

Load/Store 指令的执行对整个系统性能有很大的影响。   如果一级数据 Cache 中包括所
需的内容，那么这些指令可以很快被执行。如果数据只在二级 Cache 则稍微慢些（需要
增加额外的 11 拍）     ，如果只在主存中则会有很大的延迟。不过，乱序执行和非阻塞 Cache
可以减少由这些延时带来的性能损失。

龙芯 GS464 的二级 Cache 存放指令和数据，容量是 512KB，组织为四路组相联。它工作
在处理器主频同样的频率，采用非阻塞结构，即每拍可以访问一次。龙芯 GS464 内置 DDR2
内存控制器，最大限度地减少了内存访问的延迟。与龙芯 2E 不同，龙芯 GS464 的内存工作
频率是独立设置，与处理器主频没有关联，因此更有利于发挥内存的性能。有关内存控
制器更多的信息可以参考第十章。

龙芯 GS464 目前的这个版本没有直接提供预取指令，     但是可以通过
Load-to-Zero-Register 来获得预取的功能，即向 0 号寄存器取一个数。0
号寄存器值永远为 0，因此这样的指令
不会影响程序员可见的状态，但可以迫使一些数据进入 Cache。为了降低开销，这种指令
执行的时候不会发生访问异常，即使地址非法也会被悄悄地忽略。

编译器应该尽量减少不必要的存储访问。     目前的龙芯 GS464 处理器的存储指令延迟较大
（即使是 Cache 命中，也需要 5 个周期），同时指令窗口也没有大到可以容忍几十周期的
访问延迟。

软件还要特别注意数据对齐的问题。集合体（数组，一些纪录，子程序堆栈帧）应
该被分配在对齐的 Cache 行边界上，这样就可以利用 Cache 行对齐数据通路，还可以降
低 Cache 行被填满的数目。在那些强迫不对齐（例如 GCC 的 Packed 属性）的集合体（纪
录，普通块）中的项目中，应该产生一个编译时间的警告信息。在龙芯 GS464 中正常的
Load/Store 指令有对齐要求，不满足要求的存储访问或者采用非对齐访存指令对来访问或
者通过内核模拟来实现。例如，从非四字节对齐的地址取一个字（四字节）会触发例外，
由操作系统来处理；通常操作系统需要几千个处理器周期才能完成这个任务。因此用户
需要知道这些警告信息代表代码的性能可能会很低。编译参数的代码都默认这些参数是
对齐的。那些经常被使用的标量应该驻留在寄存器中。

\section{其他提示}

\begin{itemize}
  \item 使用所有的浮点寄存器。尽管 O32 ABI 只开放了 16 个给用户使用，但是龙芯
    GS464 提供了 32 个 64 位的浮点寄存器。使用 N32 或 N64 ABI
    有助于发挥处理器的性能。
  \item 使用性能计数器。龙芯 GS464 的性能计数器可以用来监控程序的实时性能参数。编
    译器和软件开发者可以通过分析这个结果来改进他们的代码。
\end{itemize}

